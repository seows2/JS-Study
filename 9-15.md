<br />
<br />

# 9. 타입변환

자바스크립트의 모든 값에는 타입이 있으며, 해당 타입은 개발자에 의해 의도적으로 변경되거나, 엔진에 의해 암묵적으로 변경될 수 있습니다.

이 중 개발자에 의해 의도적으로 변경되는 경우를 **명시적 타입 변환**(타입캐스팅)이라고 하며  
엔진에 의해 암묵적으로 타입이 변환되는 경우를 **암묵적 타입 변환**(타입 강제 변환)이라고 합니다.

```js
var x = 10;

// 암묵적 타입 변환
var str = x + "";
console.log(typeof str, str); // string 10

// 명시적 타입 변환
var str = String(x);

console.log(typeof str, str); // string 10
```

위 처럼 함수나 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환됩니다. 이런 과정을 **형 변환**이라고 합니다.

<br />
<br />

## 문자열 타입으로 변환

문자형으로의 형 변환은 문자형의 값이 필요할 때 이루어집니다.

```js
let value = true;
alert(typeof value); // boolean

value = String(value); // 변수 value엔 문자열 "true"가 저장됩니다.
alert(typeof value); // string
```

`false`는 문자열 `"false"`로, `null`은 `"null"`로 변환되는 등, 문자열 타입으로 변환은 예측 가능한 방식으로 일어납니다.

<br />
<br />

## 숫자 타입으로 변환

숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어납니다.

예를 들면 아래와 같은 코드입니다.

```js
const str1 = "6";
const str2 = "2";
// 암묵적 타입 변환
const num1 = str1 / str2;
// 명시적 타입 변환
const num2 = Number(str1) / Number(str2);
console.log(typeof num1, num1); // number 3
console.log(typeof num2, num2); // number 3
```

하지만 **숫자 이외의 글자가 들어가 있는 문자열**을 숫자 타입으로 변환하려고 하면 그 결과는 `NaN`이 됩니다.

```js
const age = Number("내 나이는 26살");
console.log(age); // NaN
```

아래는 숫자형으로 변환 시 적용되는 규칙입니다.

| 전달 받은 값 |                                                     형 변환 후                                                      |
| ------------ | :-----------------------------------------------------------------------------------------------------------------: |
| `undefined`  |                                                         NaN                                                         |
| `null`       |                                                          0                                                          |
| `true,false` |                                                        1, 0                                                         |
| String       | 문자열의 처음, 끝 공백 제거 후 남아있는 문자열이 없다면 `0`, <br> 그렇지 않다면 문자열에서 숫자를 읽은 후 `NaN`판별 |

```js
console.log(Number("     123  ")); // 123
console.log(Number(" 133a")); // NaN
console.log(Number(undefined)); // NaN
console.log(+null); // 0
console.log(Number(true)); // 1
console.log(Number(false)); // 0
```

여기서 유의해야할 점은 `null`과 `undefined`는 숫자형으로 변환 시 결과가 다르다는 점입니다.

<br />
<br />

## 불리언 타입으로 변환

불리언으로의 형 변환은 논리 연산을 수행할 때 발생합니다.

불린형으로 변환 시 적용되는 규칙은 아래와 같습니다.

- 숫자 `0`, `""`(빈 문자열), `null`,`,undefuned`,`NaN`과 같이 직관적으로 **비어있다**라고 느껴지는 값들은 `false`로 형 변환이 됩니다.
- 그 외의 값은 `true`로 변환됩니다.

```js
console.log(Boolean(1)); // true
console.log(Boolean(0)); // false
console.log(!!"티맥스"); // true
console.log(Boolean("0")); // true
console.log(Boolean("")); // false
```

<br />
<br />

## 단축 평가

**논리곱**(`&&`) 또는 **논리합**(`||`)연산자 표현식은 언제나 2개의 피 연산자 중, 어느 한쪽으로 평가됩니다. 논리 연산의 결과를 평가하는 도중에 평가 결과가 확정된 경우 그 값을 그대로 반환하고 나머지 평가 과정을 생략하는 것을 **단축 평가**라고 부릅니다.

```js
"Cat" && "Dog"; // "Dog"
```

1. "Cat" true
2. "Dog" true
3. "Dog" 리턴

<br />

```js
"Cat" || "Dog"; // "Cat"
```

1. "Cat" true
2. "Cat" 리턴

<br />

```js
true || anything; // true
false || anything; // anything
true && anything; // anything
false &&
  anything // false
  ``;
```

<br />
<br />

- 어떤 조건이 Truthy값일 때 무언가를 해야한다면 논리곱 연산자 표현식으로 if문을 대체할 수 있습니다.

```js
return (
  <>
    <SideTabBlock>
      {Object.values(TabType).map((tabType) => (
        <Surface
          key={tabType}
          tabType={tabType}
          onClick={onClick}
          selected={selectedTab === TabLabel[tabType]}
        />
      ))}
    </SideTabBlock>
    {selectedTab === TabLabel[TabType.TUPOL] && <TupolTabView />}
    {selectedTab === TabLabel[TabType.MONITOR] && <MonitorTabView />}
    {selectedTab === TabLabel[TabType.USER] && <UserTabView />}
  </>
);
```

- 객체가 null인지 확인하고 프로퍼티를 참조할 때

```js
var elem = null;

console.log(elem.value); // TypeError: Cannot read property 'value' of null
console.log(elem && elem.value); // null
console.log(elem?.value); // undefined
```

<br />
<br />

# 10. 객체란

자바스크립트는 데이터 저장을 위해 7가지의 원시자료형과 객체, 2가지 종류의 자료형을 사용합니다. 원시형은 오직 하나의 데이터만을 담을 수 있어 원시형이라 부릅니다.

하지만 객체형은 원시형과 달리 다양한 데이터를 담을 수 있습니다. Key와 Value로 구성된 Property를 여러개 넣을 수 있는데 Key에는 문자열, Value에는 모든 자료형이 허용됩니다.
그리고 특별히 Property의 값이 함수일 경우에는 메소드라고 부르기도 합니다.

<br/>
<br/>

## 객체의 생성

자바스크립트에서 다양한 객체 생성 방법을 가지고 있습니다.

- 객체 리터럴
- Object 객체 생성자
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

이 중 가장 일반적이고 간단한 방법은 객체리터럴을 사용하는 것입니다.

```js
const user1 = new Object(); // 객체 생성자 문법
user1.name = "서우석";
user1.age = 26;

const user2 = {
  name: "서우석",
  age: 26,
}; // 객체 리터럴 문법

function User(name, age) {
  this.name = name;
  this.age = age;
  this.sayHello = function () {
    console.log(`안녕! 나는 ${name}!`);
  };
}

const user3 = new User("서우석", 26); // 생성자 함수
```

## 객체 프로퍼티 접근

객체의 프로퍼티 값에 접근하는 방법은 두가지 입니다.

- 마침표 프로퍼티 접근 연산자.를 사용하는 마침표 표기법
- 대괄호 프로퍼티 접근 연산자[]를 사용하는 대괄호 표기법

```js
var person = {
  "first-name": "우석",
  "last-name": "서",
  age: 26,
};
console.log(person.age); // 26
console.log(person["first-name"]); // '우석'
```

### 프로퍼티 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됩니다.

```js
var person = {
  name: "우석",
};
person.name = "서우석";
```

### 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당됩니다.

```js
var person = {
  name: "우석",
};
person.age = 26;
```

### 프로퍼티 동적 생성

`delete`연산자는 객체의 프로퍼티를 삭제합니다. 이때 `delete`연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 합니다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러 없이 무시됩니다.

```js
var person = {
  name: "우석",
};
person.age = 26;

delete person.age;

delete person.adderss; // 무시됨 에러 발생 X
```

### property shorthand

ES6에서는 property shorthand(단축 속성명)을 제공합니다.
property shorthand는 객체를 정의 할 때 객체의 key값과 value의 값이 같으면, key 와 value 값을 각각 표기하지 않고 한 번만 표기하는 것을 의미합니다.

```js
const a = "foo";
const b = 42;
const c = {};
//아래와 같이 작성할 수도 있지만
const object = {
  a: a,
  b: b,
  c: c,
};
// ES6의 property shorthand를 이용하여 간견하게 표기할 수 있다.
const object = {
  a,
  b,
  c,
};
```

<br />
<br />

# 10. 객체의 변경불가성

객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제될 수 있습니다. 또한 프로퍼티의 값에도 제약이 없습니다. 따라서 객체는 원시 값과 같이 확보해야할 메모리 공간의 크기를 사전에 정할 수가 없는데요. 객체는 복합적인 자료구조이므로 객체를 관리하는 방식이 원시 값과 비교해서 보다 복잡합니다. 원시 값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에 따라 크기가 매우 클 수도 있습니다. 그래서 객체를 생성하고 프로퍼티에 접근하는 것도 원시 값과 비교할 때 비용이 많이 드는 일입니다. 그래서 객체는 원시 값과 다른 방식으로 동작합니다

객체(참조) 타입은 원시값과 다르게 변경 가능한 값(mutable value) 입니다.
먼저 변수에 객체를 할당하면 어떤 일이 발생할까요?

```js
var user = {
  name: "우석",
};
```

위와 같이 선언했을 때 객체를 할당한 변수는 동적으로 변할 수 있는 메모리 공간에 있는 데이터의 주소를 가리키는 참조값을 갖습니다. 여기서 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체입니다. 그래서 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근합니다.

```js
var user = {
  name: "석석석",
};

//참조값을 복사하게됨, 얕은 복사
var copy = user;

console.log(copy === user); // true

copy.name = "우석";
user.address = "Seoul";

console.log(user); // {name: "우석", address: "Seoul"}
console.log(copy); // {name: "우석", address: "Seoul"}
```

객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달됩니다. 이를 참조에 의한 전달이라고 합니다.

원본 person을 사본 copy에 할당하면 원본 person의 참조 값을 복사해서 copy에 저장합니다. 이 때 원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖습니다. 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가, 삭제)하면 서로 영향을 주고받습니다.

### 불변 데이터 패턴

의도하지 않은 객체의 변경이 발생하는 원인의 대다수는 “레퍼런스를 참조한 다른 객체에서 객체를 변경”하기 때문이다. 이 문제의 해결 방법은 비용은 조금 들지만 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경하는 방식입니다.

이를 위해서는 여러가지 방법이 있습니다.

- 객체의 방어적 복사(defensive copy)
  - Object.assign
- 불변객체화를 통한 객체 변경 방지
  - Object.freeze

### Object.assign

### Object.freeze

### 라이브러리

<br/>
<br/>

# 함수

함수란 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다.
