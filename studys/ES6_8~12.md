# 8 모듈

# 9 프로미스

웹페이지는 서버와 통신할 수 있어야합니다. 프론트엔드에서 이 통신을 어떻게 다루는지를 알아야하는데요. 통신이란 것은 실행 시간이 정확히 얼마나 걸릴지 알 수 없는 작업이기 때문에, 프로그래머들은 **프로미스**를 만들었습니다.

## 프로미스가 뭘까?

**프로미스**란 MDN문서에서 아래와 같이 설명하고 있습니다.

> Promise는 프로미스가 생성될 때 꼭 알 수 있지는 않은 값을 위한 대리자로, 비동기 연산이 종료된 이후의 결과값이나 실패 이유를 처리하기 위한 처리기를 연결할 수 있도록 합니다. 프로미스를 사용하면 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있습니다. 다만 최종 결과를 반환하지는 않고, 대신 프로미스를 반환해서 미래의 어떤 시점에 결과를 제공합니다.

여기서 가장 중요한 것은 **미래의 어떤 시점에 결과를 제공**한다는 것입니다. 이를 한마디로 표현하면 **미랫값**이라고 볼 수 있습니다.

<br>

예를 들면 카페에 가서 🍓딸기라떼를 주문을 하면, 직원은 🛎**진동벨**을 넘겨줍니다. 이 진동벨이 **프로미스**입니다.

이 진동벨은 미래에 내가 딸기라떼를 받을 수 있을 것이라는 **약속**입니다. 이 약속을 기다리면서 다른 일들을 할 수 있습니다. 그리고 진동벨이 울리면 카운터에서 딸기라떼를 받아와 즐길 수 있습니다.

하지만 이런 상황이 발생할 수도 있습니다. 진동벨이 울려서 카운터에 갔더니, "오늘 딸기 재고가 다 떨어져서 주문이 불가능합니다. ㅠㅠ"라고 합니다. 그러면 다른 메뉴를 고민하고 요청하던가 포기해야합니다.

**이처럼 미랫값인 🛎프로미스는 성공할 수도, 실패할 수도 있습니다.**

이런 미랫값을 다루기 위한 프로미스가 등장하기 전에 사용하던 방법은 콜백이었습니다.

```js
setTimeout(
  (name) => {
    let coffeeList = name;
    console.log(coffeeList);

    setTimeout(
      (name) => {
        coffeeList += ", " + name;
        console.log(coffeeList);

        setTimeout(
          (name) => {
            coffeeList += ", " + name;
            console.log(coffeeList);

            setTimeout(
              (name) => {
                coffeeList += ", " + name;
                console.log(coffeeList);
              },
              500,
              "Latte"
            );
          },
          500,
          "Mocha"
        );
      },
      500,
      "Americano"
    );
  },
  500,
  "Espresso"
);
```

콜백 함수는 비동기 데이터를 다루기에 간편하고, 오랜 시간 동안 표준적인 방법이었습니다. 하지만 서비스의 로직이 복잡해지고 여러 비동기 동작들이 필요한 시점부터 비동기 함수에서 다른 비동기 함수를 호출하고, 거기서 또 다른 비동기 함수를 호출하는 등의 중첩이 발생합니다. 이런 경우를 흔히 **'콜백 지옥'** 에 빠졌다고 합니다. 게다가 콜백의 연결은 에러 처리를 하는 경우에서도 상당히 곤란한 상황을 만들어냅니다.

```js
try {
  setTimeout(() => {
    throw new Error("Error!");
  }, 1000);
} catch (e) {
  console.log("에러를 캐치하지 못한다..");
  console.log(e);
}
```

try 블록 내에서 setTimeout 함수가 실행되면 1초 후에 콜백 함수가 실행되고 이 콜백 함수는 예외를 발생시킵니다. 하지만 이 예외는 catch 블록에서 catch되지 않습니다. 이미 try catch 문을 빠져나온 다음에 setTimeout 함수가 1초 뒤에 실행되기 때문입니다.

게다가 보통 비동기 함수들은 두 개의 콜백 함수를 전달받습니다. **요청이 성공한 경우에 실행할 콜백 함수**와 **오류가 발생했을 때 실행할 콜백 함수**가 필요하기 때문입니다. 이로 인해 복잡성이 2배 이상 증가하죠.

<br>

## 그래서 프로미스가 등장했다!

하지만 프로미스를 활용하면 콜백 함수 문제를 간편하게 만들 수 있습니다. 프로미스는 콜백 함수를 인자로 받는 대신에, **성공과 실패에 대응하는 메서드**를 제공합니다. 그리고 콜백 함수를 중첩하지 않고, 여러 개의 비동기 동작을 연결할 수 있는 방법을 제공합니다

<br>

## 프로미스의 생성

프로미스는 Promise 생성자 함수를 통해 인스턴스화한다. Promise 생성자 함수는 비동기 작업을 수행할 콜백 함수를 인자로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인자로 전달받습니다.

`Promise`는 다음 중 하나의 상태를 가집니다.

- 대기(pending): 이행하거나 거부되지 않은 초기 상태.
- 이행(fulfilled): 연산이 성공적으로 완료됨.
- 거부(rejected): 연산이 실패함.

```js
const promise = new Promise((resolve, reject) => {
  //비동기 작업을 수행.

  if(/* 비동기 작업 수행 성공*/)) {
    resolve("result");
  } else { /* 비동기 작업 수행 실패*/
    reject(new Error("failure reason"));
  }
})
```

프로미스는 비동기 작업을 전달받아서 응답에 따라 두 가지 메서드 중 하나를 호출하는 객체입니다. 프라미스는 비동기 작업이 성공하거나 충족된 경우 then() 메서드에 결과를 넘겨줍니다. 비동기 작업에 실패하거나 거부되는 경우에는 catch() 메서드를 호출합니다. then()과 catch() 메서드에는 모두 함수를 인자로 전달합니다. 이때 두 메서드에 전달되는 함수에는 비동기 작업의 결과인 응답만이 인수로 전달됩니다.

프로미스는 두 개의 인자, resolve() 와 reject() 를 전달받습니다. resolve()는 코드가 정상적으로 동작했을 때 실행됩니다. resolve()가 호출되면 then() 메서드에 전달된 함수가 실행됩니다. 프로미스를 설정할 때 then()과 catch() 메서드를 모두 사용할 수 있습니다. then() 메서드는 성공한 경우를 처리하고, catch() 메서드는 거절된 경우를 처리합니다.

```js
new Promise(function (resolve, reject) {
  // ...
})
  .then(resolve())
  .catch(reject());
```

![Promise](../images/promise.png)

# 10 7번째 타입 심볼

# 11 이터레이션과 for...of문

# 12 제너레이터와 async/await
